<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amadori Basketball</title>
   <link rel="icon" href="assets/icon/favicon.ico" type="image/x-icon">
  <script src="js/phaser.min.js"></script>
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,100;1,800;1,900&display=swap" rel="stylesheet">

  <link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#005832">

</head>
<body>
  <div class="page" id="pageIntro">
    <img class="centeredLogo" src="assets/images/amadori_logo.svg" alt="Logo Amadori">
    <h1>Benvenut*!</h1>
    <div class="textContainer">
        <p class="subtitle">Pront* per il <br> <span>Basket Corner</span> di Amadori? üèÄ</p>
        <p class="description">Metti alla prova il tuo talento! <br> Tira, segna e scala la classifica:  <br> pi√π punti fai, pi√π diventerai un PRO!</p>
    </div>
    <button class="button" id="startButton">Gioca ora</button>
  </div>

  <div class="page" id="pageGameOver">
    <img class="centeredLogo" src="assets/images/amadori_logo.svg" alt="Logo Amadori">
    <h1>Game over</h1>
    <div class="textContainer">
        <p class="subtitle">Hai esaurito i tuoi <span id="max-shots-gameover">20</span> tiri üèÄ <br>
        e totalizzato <span id="final-score">0</span> canestri! </p>
        <p class="description">Riprova a supera il tuo record</p>
    </div>
    <button class="button" id="restartButton">Gioca ancora</button>
  </div>

  <div class="pageGameHeader">
    <img src="assets/images/amadori_logo.svg" alt="Logo Amadori">
  </div>

  <div id="shotsCounter">
    Tiri: <span id="currentShots">0</span>/<span id="max-shots">20</span>
  </div>

  <div class="GameContainer" id="game-container"></div>
  <div class="footer">
    <span class="footerDesc">Trascina rapidamente la palla per lanciarla nel canestro!</span>
  </div>

<script>

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
      .then(() => console.log('SW registrato'))
      .catch(err => console.error('Errore SW:', err));
  }

    var gameWidth = 810;
    var gameHeight = 1080;

    var game = new Phaser.Game(gameWidth, gameHeight, Phaser.CANVAS, 'game-container', {
      preload: preload,
      create: create,
      update: update
    });

    var introShown = false; // Variabile per tenere traccia se l'introduzione √® stata mostrata
    var totalShots = 0;     // Contatore dei tiri
    var maxShots = 5;      // Numero massimo di tiri consentiti
    var gameOverScreen;     // Riferimento al div della schermata di game over
    var finalScoreText;     // Riferimento allo span del punteggio finale
    var restartButton;      // Riferimento al pulsante di riavvio

    // Nuove variabili per il contatore dei tiri nell'HTML
    var currentShotsElement;
    var maxShotsElement;

    function preload() {
      game.load.image('field', 'assets/images/field.png');

      game.load.image('ball', 'assets/images/ball.png');
      game.load.image('hoop', 'assets/images/hoop_new_1.png');
      game.load.image('side rim', 'assets/images/side_rim.png');
      game.load.image('front rim', 'assets/images/front_rim.png');

      var winImages = ['win0', 'win1', 'win2'];
      var loseImages = ['lose0', 'lose1', 'lose2'];

      winImages.forEach(function(name) {
        game.load.image(name, 'assets/images/' + name + '.png');
      });
      loseImages.forEach(function(name) {
        game.load.image(name, 'assets/images/' + name + '.png');
      });

      game.load.audio('score', 'assets/audio/score.wav');
      game.load.audio('backboard', 'assets/audio/backboard.wav');
      game.load.audio('whoosh', 'assets/audio/whoosh.wav');
      game.load.audio('fail', 'assets/audio/fail.wav');
      game.load.audio('spawn', 'assets/audio/spawn.wav');
    }

    var hoop, left_rim, right_rim, ball, front_rim, field_background;
    var current_score = 0, current_score_text, high_score = 0, current_best_text, current_best_score_text;
    var score_sound, backboard, whoosh, fail, spawn;
    var moveInTween, fadeInTween, moveOutTween, fadeOutTween, emoji, emojiName;
    var collisionGroup;
    var isDown = false, start_location, end_location, location_interval;

    // Aggiungi queste variabili per gli sfondi del testo
    var current_score_bg; // Sfondo per il punteggio corrente
    var high_score_bg;    // Sfondo per il record

    var scaleFactor = 2;

    function create() {
      // Riprendi l'AudioContext al primo input utente (click/tap)
        game.input.onDown.addOnce(() => {
          if (game.sound.context.state === 'suspended') {
            game.sound.context.resume().then(() => {
              console.log('AudioContext resumed!');
            });
          }
        });

      
      game.scale.scaleMode = Phaser.ScaleManager.EXACT_FIT;
      game.scale.pageAlignHorizontally = true;
      game.scale.pageAlignVertically = true;
      game.scale.refresh();

      window.addEventListener('resize', function () {
        game.scale.refresh();
      });

      game.physics.startSystem(Phaser.Physics.P2JS);
      game.physics.p2.setImpactEvents(true);
      game.physics.p2.restitution = 0.63;
      game.physics.p2.gravity.y = 2500 * scaleFactor;
      collisionGroup = game.physics.p2.createCollisionGroup();

      score_sound = game.add.audio('score');
      backboard = game.add.audio('backboard'); backboard.volume = 0.5;
      whoosh = game.add.audio('whoosh');
      fail = game.add.audio('fail'); fail.volume = 0.1;
      spawn = game.add.audio('spawn');

      // Imposta il colore di sfondo verde dello stage di Phaser
      game.stage.backgroundColor = "#005832";

      field_background = game.add.sprite(game.world.centerX, game.world.height - 70, 'field');
      field_background.anchor.setTo(0.5, 1);

      var scaleX = game.world.width / field_background.width;
      var scaleY = game.world.height / field_background.height;
      var scale = Math.min(scaleX, scaleY);

      field_background.scale.setTo(scale);
      field_background.sendToBack();

      hoop = game.add.sprite(gameWidth / 2, gameHeight * 0.10, 'hoop');
      hoop.anchor.setTo(0.5, 0);
      hoop.scale.setTo(1, 1);

      left_rim = game.add.sprite(hoop.x - (50 * scaleFactor), hoop.y + (103 * scaleFactor), 'side rim');
      left_rim.anchor.setTo(0.5, 0.5);
      left_rim.scale.setTo(scaleFactor, scaleFactor);

      right_rim = game.add.sprite(hoop.x + (50 * scaleFactor), hoop.y + (103 * scaleFactor), 'side rim');
      right_rim.anchor.setTo(0.5, 0.5);
      right_rim.scale.setTo(scaleFactor, scaleFactor);

      game.physics.p2.enable([left_rim, right_rim], false);
      left_rim.body.setCircle(5 * scaleFactor);
      left_rim.body.static = true;
      right_rim.body.setCircle(5 * scaleFactor);
      right_rim.body.static = true;

      left_rim.body.setCollisionGroup(collisionGroup);
      right_rim.body.setCollisionGroup(collisionGroup);
      left_rim.body.collides([collisionGroup]);
      right_rim.body.collides([collisionGroup]);

      // Sfondo per il punteggio corrente
      current_score_bg = game.add.graphics(0, 0);
      current_score_bg.beginFill(0x8bc34a, 0.8);
      current_score_bg.drawCircle(gameWidth / 2, hoop.y + (250 * scaleFactor), 60);
      current_score_bg.endFill();
      current_score_bg.alpha = 0;

      // Sfondo per il record (high score)
      high_score_bg = game.add.graphics(0, 0);
      high_score_bg.beginFill(0x8bc34a, 0.8);
      high_score_bg.drawCircle(gameWidth / 2, hoop.y + (250 * scaleFactor), 60);
      high_score_bg.endFill();
      high_score_bg.alpha = 0;

      current_score_text = game.add.text(gameWidth / 2, hoop.y + (250 * scaleFactor), '0', { font: 'Arial', fontSize: '40px', fill: '#FFF', align: 'center' });
      current_score_text.anchor.setTo(0.5, 0.5);

      current_best_text = game.add.text(gameWidth / 2, hoop.y + (220 * scaleFactor), '', { font: 'Arial', fontSize: '36px', fill: '#FFF', align: 'center' });
      current_best_text.anchor.setTo(0.5, 0.5);

      current_best_score_text = game.add.text(gameWidth / 2, hoop.y + (250 * scaleFactor), '', { font: 'Arial', fontSize: '40px', fill: '#FFF', align: 'center' });
      current_best_score_text.anchor.setTo(0.5, 0.5);

      // Posiziona il testo sopra il suo sfondo
      current_score_bg.bringToBack = false;
      game.world.bringToTop(current_score_bg);
      game.world.bringToTop(high_score_bg);
      game.world.bringToTop(current_score_text);
      game.world.bringToTop(current_best_text);
      game.world.bringToTop(current_best_score_text);

      createBall();

      // Gestione della pagina introduttiva
      var introScreen = document.getElementById('pageIntro');
      var startButton = document.getElementById('startButton');
      gameOverScreen = document.getElementById('pageGameOver');
      finalScoreText = document.getElementById('final-score');
      restartButton = document.getElementById('restartButton');

      restartButton.addEventListener('click', restartGame);

      // Inizializza gli elementi del contatore tiri
      currentShotsElement = document.getElementById('currentShots');
      maxShotsElement = document.getElementById('max-shots');
      maxShotsElement.textContent = maxShots;

      var maxShotGameover = document.getElementById('max-shots-gameover')
      maxShotGameover.textContent = maxShots;

      updateShotsCounter();

      // Aggiungi un listener solo al pulsante
      startButton.addEventListener('click', function() {
        console.log('dentro al click di start');
          if (!introShown) {
            console.log('dentro qua');
              introScreen.classList.add('fade-out');
              setTimeout(function() {
                  introScreen.style.display = 'none';
                  introShown = true;
                  game.input.onDown.add(click, this);
                  game.input.onUp.add(release, this);
              }.bind(this), 1000);
          }
      }.bind(this));
    }


    function updateShotsCounter() {
        currentShotsElement.textContent = totalShots;
    }

    function restartGame() {
        gameOverScreen.classList.remove('show');

        totalShots = 0;
        current_score = 0;
        
        createBall();
        current_score_text.text = current_score;
        current_score_text.alpha = 1;
        current_score_bg.alpha = 1;
        
        current_best_text.alpha = 0;
        current_best_score_text.alpha = 0;
        high_score_bg.alpha = 0;

        updateShotsCounter();

        game.input.onDown.add(click, this);
        game.input.onUp.add(release, this);
    }

    function update() {
        if (!introShown) {
            return;
        }

        if (ball && ball.body.velocity.y > 0 && !front_rim) {
            front_rim = game.add.sprite(hoop.x - (50 * scaleFactor), hoop.y + (100 * scaleFactor), 'front rim');
            front_rim.scale.setTo(scaleFactor, scaleFactor);
        }
        if (ball && ball.body.velocity.y < 0 && front_rim) {
            front_rim.destroy();
            front_rim = null;
        }

        if (ball && ball.body.velocity.y > 0) {
            ball.body.collides([collisionGroup], hitRim, this);
        }

        if (ball && ball.body.velocity.y > 0 && ball.body.y > (hoop.y + hoop.height * 0.75) && !ball.isBelowHoop) {
            ball.isBelowHoop = true;
            ball.body.collideWorldBounds = false;

            var rand = Math.floor(Math.random() * 3);
            if (ball.body.x > left_rim.x && ball.body.x < right_rim.x) {
                emojiName = "win" + rand;
                current_score += 1;
                current_score_text.text = current_score;
                score_sound.play();

                if (current_score > high_score) {
                    high_score = current_score;
                }
                
                current_score_bg.alpha = 1;
                current_score_text.alpha = 1;
                high_score_bg.alpha = 0;
                current_best_text.alpha = 0;
                current_best_score_text.alpha = 0;

            } else {
                emojiName = "lose" + rand;
                fail.play();
                
                current_score_text.alpha = 0;
                current_score_bg.alpha = 0;

                // Rimosse o commentate le seguenti righe per eliminare "Il tuo record"
                // current_best_text.text = 'Il tuo record';
                // current_best_score_text.text = high_score;
                // high_score_bg.alpha = 1;
                // current_best_text.alpha = 1;
                // current_best_score_text.alpha = 1;
            }
            emoji = game.add.sprite(gameWidth / 2, hoop.y + (70 * scaleFactor), emojiName);
            emoji.anchor.setTo(0.5, 0.5);
            emoji.scale.setTo(0.25 * scaleFactor, 0.25 * scaleFactor);
            moveInTween = game.add.tween(emoji).from({ y: emoji.y + (50 * scaleFactor) }, 500, Phaser.Easing.Elastic.Out, true);
            fadeInTween = game.add.tween(emoji).from({ alpha: 0 }, 200, Phaser.Easing.Linear.None, true, 0, 0, false);
            moveInTween.onComplete.add(tweenOut, this);
        }

        if (ball && ball.body.y > gameHeight + (gameHeight * 0.2)) {
            game.physics.p2.gravity.y = 0;
            ball.kill();
            ball = null;

            if (totalShots >= maxShots) {
                endGame();
            } else {
                createBall();
            }
        }
    }

    function tweenOut() {
      moveOutTween = game.add.tween(emoji).to({ y: emoji.y - (50 * scaleFactor) }, 600, Phaser.Easing.Elastic.In, true);
      moveOutTween.onComplete.add(() => emoji.kill(), this);
      setTimeout(() => {
        fadeOutTween = game.add.tween(emoji).to({ alpha: 0 }, 300, Phaser.Easing.Linear.None, true, 0, 0, false);
      }, 450);
    }

    function hitRim() {
      backboard.play();
    }

    function createBall() {
      
var xpos = gameWidth / 2;  // o la posizione orizzontale che vuoi
  var fixedY = gameHeight * 0.82;

  spawn.play();
  ball = game.add.sprite(xpos, fixedY, 'ball');
  ball.anchor.setTo(0.5, 0.5);
  game.add.tween(ball.scale).from({ x: 0.7 * scaleFactor, y: 0.7 * scaleFactor }, 100, Phaser.Easing.Linear.None, true);
  
  game.physics.p2.enable(ball, false);

  // Allinea posizione fisica a quella dello sprite
  ball.body.x = ball.x;
  ball.body.y = ball.y;

  ball.body.setCircle(60 * scaleFactor * 0.6);
  ball.launched = false;
  ball.isBelowHoop = false;

  // Disabilita gravit√† fino al lancio
  game.physics.p2.gravity.y = 0;

  current_score_text.text = current_score;
  current_score_text.alpha = 1;
  current_score_bg.alpha = 1;

  current_best_text.alpha = 0;
  current_best_score_text.alpha = 0;
  high_score_bg.alpha = 0;
    }

    function click(pointer) {
      var bodies = game.physics.p2.hitTest(pointer.position, [ball.body]);
      if (bodies.length) {
        start_location = [pointer.x, pointer.y];
        isDown = true;
        location_interval = setInterval(() => {
          start_location = [pointer.x, pointer.y];
        }, 200);
      }
    }

    function release(pointer) {
      if (isDown) {
        clearInterval(location_interval);
        isDown = false;
        end_location = [pointer.x, pointer.y];
        if (end_location[1] < start_location[1]) {
          var slope = [end_location[0] - start_location[0], end_location[1] - start_location[1]];
          // Ho modificato questo valore per ridurre la velocit√† laterale del tiro.
          // Un valore pi√π basso (pi√π vicino a 0) render√† la palla meno influenzata dal movimento orizzontale.
          // Era -2300 * scaleFactor, ora √® -1500 * scaleFactor.
          var x_traj = -1500 * scaleFactor * slope[0] / slope[1];
          launch(x_traj);
        }
      }
    }
function launch(x_traj) {
  if (!ball.launched) {
    ball.body.setCircle(36 * scaleFactor * 0.6);
    ball.body.setCollisionGroup(collisionGroup);

    high_score_bg.alpha = 0;
    current_best_text.alpha = 0;
    current_best_score_text.alpha = 0;
    current_score_bg.alpha = 1;
    current_score_text.alpha = 1;

    ball.launched = true;

    // Ripristina gravit√† solo al lancio
    game.physics.p2.gravity.y = 2500 * scaleFactor;

    game.add.tween(ball.scale).to({ x: 0.6 * scaleFactor, y: 0.6 * scaleFactor }, 500, Phaser.Easing.Linear.None, true);
    ball.body.velocity.x = x_traj;
    ball.body.velocity.y = -1500 * scaleFactor;
    ball.body.rotateRight(x_traj / 3);
    whoosh.play();

    totalShots++;
    updateShotsCounter();
  }
}


  function endGame() {
      game.input.onDown.removeAll();
      game.input.onUp.removeAll();

      if (ball) {
          ball.kill();
          ball = null;
      }

      current_score_text.alpha = 0;
      current_score_bg.alpha = 0;
      current_best_text.alpha = 0;
      current_best_score_text.alpha = 0;
      high_score_bg.alpha = 0;

      finalScoreText.textContent = current_score;
      gameOverScreen.classList.add('show');

      // Reset variabili punteggio e tiri
      totalShots = 0;
      current_score = 0;
      updateShotsCounter();
  }
  </script>
</body>
</html>